<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Studio (Local) ‚Äî Annotations</title>

  <!-- pdf-lib (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <!-- PDF.js (UMD) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    :root { font-family: Arial, Helvetica, sans-serif; }
    body { margin:0; background:#0f1115; color:#e7e7e7; }
    .app { display:grid; grid-template-columns: 330px 1fr; height:100vh; }

    .left { border-right:1px solid #242833; background:#121521; display:flex; flex-direction:column; min-width:260px; }
    .toolbar { padding:12px; border-bottom:1px solid #242833; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .btn { background:#1e2433; color:#e7e7e7; border:1px solid #2a3144; padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px; user-select:none; }
    .btn:hover { background:#242c3f; }
    .btn.primary { background:#2b5cff; border-color:#2b5cff; }
    .btn.danger { background:#3a1e22; border-color:#5a2a32; }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    .btn.toggleOn { outline:2px solid #2b5cff; }

    input[type="file"]{ display:none; }

    .drop { margin:12px; border:1px dashed #3b4257; border-radius:14px; padding:12px; font-size:13px; color:#b9c0d4; }
    .drop strong { color:#fff; }

    .thumbs { overflow:auto; padding:0 12px 12px; }
    .thumb {
      border:1px solid #242833; background:#0f1115; border-radius:14px;
      margin-top:10px; padding:10px; display:grid; grid-template-columns:72px 1fr; gap:10px;
      cursor:pointer;
    }
    .thumb.active { outline:2px solid #2b5cff; }
    .thumb[draggable="true"] { user-select:none; }
    .thumb:active { cursor:grabbing; }
    .thumb canvas, .thumb img { width:72px; height:96px; object-fit:cover; border-radius:10px; background:#0b0d12; display:block; }
    .meta { font-size:12px; color:#cfd6ea; }
    .small { color:#98a2bd; font-size:11px; margin-top:4px; }

    .right { display:flex; flex-direction:column; }
    .topbar {
      padding:12px 14px; border-bottom:1px solid #242833;
      display:flex; justify-content:space-between; gap:10px; align-items:flex-start; flex-wrap:wrap;
    }
    .status { color:#b9c0d4; font-size:13px; }

    .modebar { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .pill { border:1px solid #2a3144; background:#171c29; color:#e7e7e7; border-radius:999px; padding:6px 10px; font-size:12px; user-select:none; }

    .props {
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      border:1px solid #242833; background:#0b0d12; border-radius:14px;
      padding:10px 12px;
      max-width: 860px;
    }
    .props .group { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .props label { font-size:12px; color:#b9c0d4; display:flex; align-items:center; gap:6px; }
    .props input[type="number"]{
      width:72px; background:#111522; color:#e7e7e7; border:1px solid #2a3144;
      border-radius:10px; padding:6px 8px; font-size:12px;
    }
    .props input[type="text"]{
      width:220px; background:#111522; color:#e7e7e7; border:1px solid #2a3144;
      border-radius:10px; padding:6px 8px; font-size:12px;
    }
    .props input[type="color"]{
      width:40px; height:32px; border:none; background:transparent; padding:0;
      cursor:pointer;
    }
    .props select{
      background:#111522; color:#e7e7e7; border:1px solid #2a3144;
      border-radius:10px; padding:6px 8px; font-size:12px;
    }

    .viewer { flex:1; overflow:auto; display:flex; justify-content:center; align-items:flex-start; padding:18px; }
    .page { background:#0b0d12; border:1px solid #242833; border-radius:16px; padding:14px; min-width:320px; }
    .canvasWrap { position:relative; display:inline-block; max-width:900px; width:100%; }
    #previewCanvas { width:100%; height:auto; border-radius:10px; background:#0b0d12; display:block; }

    /* SVG overlay */
    #svgOverlay {
      position:absolute; left:0; top:0;
      width:100%; height:100%;
      pointer-events:auto;
      overflow:visible;
    }

    /* selection highlight */
    .selBox { fill: none; stroke: #2b5cff; stroke-width: 2; stroke-dasharray: 6 4; }
    .handle { fill:#2b5cff; stroke: rgba(0,0,0,0.4); stroke-width:2; cursor: nwse-resize; }

    /* Crop overlay (separate) */
    #cropBox {
      position:absolute;
      border:2px solid #2b5cff;
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.35);
      border-radius:8px;
      display:none;
      cursor:move;
    }
    #cropBox .br {
      position:absolute; width:12px; height:12px; background:#2b5cff;
      border-radius:999px; border:2px solid rgba(0,0,0,0.4);
      right:-8px; bottom:-8px; cursor:nwse-resize;
    }

    .hint { font-size:12px; color:#98a2bd; margin-top:8px; }
    .note { padding:10px 14px; font-size:12px; color:#98a2bd; border-top:1px solid #242833; }
  </style>
</head>

<body>
  <div class="app">
    <aside class="left">
      <div class="toolbar">
        <label class="btn">
          Ajouter
          <input id="fileInput" type="file" multiple accept="application/pdf,image/*">
        </label>
        <button class="btn danger" id="clearBtn">Vider</button>
        <button class="btn primary" id="exportBtn">Exporter PDF</button>
      </div>

      <div class="drop" id="dropZone">
        <div><strong>D√©pose</strong> tes PDF / images ici</div>
        <div style="margin-top:6px;">Tout est trait√© <strong>en local</strong> (aucun upload).</div>
        <div style="margin-top:6px;">Glisse les miniatures pour changer l‚Äôordre.</div>
      </div>

      <div class="thumbs" id="thumbs"></div>

      <div class="note">
        ‚úÖ S√©lection / d√©placer / double-clic pour √©diter texte<br/>
        ‚úÖ Couleurs texte + formes (contour/remplissage)<br/>
        ‚úÖ Ligne / fl√®che / smiley<br/>
        ‚úÖ Export PDF (tout rejou√© en pdf-lib)
      </div>
    </aside>

    <main class="right">
      <div class="topbar">
        <div>
          <div class="status" id="status">Aucun document charg√©</div>
          <div class="modebar" style="margin-top:8px;">
            <span class="pill" id="pageInfo">‚Äî</span>

            <button class="btn" id="toolSelectBtn">S√©lection</button>

            <button class="btn" id="toolTextBtn">Texte</button>
            <button class="btn" id="toolRectBtn">Carr√©</button>
            <button class="btn" id="toolCircleBtn">Rond</button>
            <button class="btn" id="toolLineBtn">Ligne</button>
            <button class="btn" id="toolArrowBtn">Fl√®che</button>
            <button class="btn" id="toolSmileyBtn">Smiley</button>

            <span class="pill" style="opacity:.85;">|</span>

            <button class="btn" id="modeCropBtn">Rogner</button>
            <button class="btn" id="applyCropBtn" disabled>Appliquer</button>
            <button class="btn" id="resetCropBtn" disabled>Reset rognage</button>

            <button class="btn danger" id="delAnnotBtn" disabled>Suppr objet</button>
            <button class="btn danger" id="delPageBtn">Supprimer page</button>
          </div>
        </div>

        <!-- Properties panel -->
        <div class="props" id="propsPanel" style="display:none;">
          <div class="group" id="propsCommon">
            <span class="pill" id="propsKind">Objet</span>
          </div>

          <div class="group" id="propsText" style="display:none;">
            <label>Texte <input type="text" id="textValue" /></label>
            <label>Taille <input type="number" id="textSize" min="6" max="200" step="1" /></label>
            <label>Couleur <input type="color" id="textColor" /></label>
          </div>

          <div class="group" id="propsStrokeFill" style="display:none;">
            <label>Contour <input type="color" id="strokeColor" /></label>
            <label>√âpaisseur <input type="number" id="strokeWidth" min="1" max="40" step="1" /></label>
            <label>Remplissage
              <select id="fillMode">
                <option value="none">Transparent</option>
                <option value="color">Couleur</option>
              </select>
            </label>
            <label id="fillColorWrap" style="display:none;">Couleur <input type="color" id="fillColor" /></label>
          </div>

          <div class="group" id="propsEmoji" style="display:none;">
            <label>Smiley
              <select id="emojiSelect">
                <option value="üôÇ">üôÇ</option>
                <option value="üòä">üòä</option>
                <option value="üòÄ">üòÄ</option>
                <option value="üòé">üòé</option>
                <option value="üòç">üòç</option>
                <option value="‚ö†Ô∏è">‚ö†Ô∏è</option>
                <option value="‚úÖ">‚úÖ</option>
                <option value="‚ùå">‚ùå</option>
              </select>
            </label>
            <label>Taille <input type="number" id="emojiSize" min="10" max="300" step="1" /></label>
          </div>
        </div>
      </div>

      <div class="viewer">
        <div class="page">
          <div class="canvasWrap" id="canvasWrap">
            <canvas id="previewCanvas"></canvas>

            <!-- SVG annotation overlay -->
            <svg id="svgOverlay"></svg>

            <!-- Crop overlay -->
            <div id="cropBox"><div class="br"></div></div>
          </div>

          <div class="hint" id="hint">Charge un fichier pour afficher l‚Äôaper√ßu.</div>
        </div>
      </div>
    </main>
  </div>

<script>
(() => {
  const { PDFDocument, StandardFonts, rgb } = PDFLib;
  const pdfjsLib = window['pdfjs-dist/build/pdf'] || window.pdfjsLib || window['pdfjsLib'];
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

  // ---------- STATE ----------
  /**
   * item:
   *  pdf: { type:'pdf', srcPdfU8, pageIndex, crop?, annots:[] }
   *  img: { type:'img', dataUrl, crop?, annots:[] }
   *
   * crop:
   *  pdf (points): { left,bottom,right,top }
   *  img (pixels): { x,y,w,h }
   *
   * annots:
   *  text:  {id, kind:'text', xN,yN, text, size, color}
   *  rect:  {id, kind:'rect', xN,yN,wN,hN, stroke, strokeW, fill} fill = null or '#RRGGBB'
   *  circ:  {id, kind:'circle', xN,yN,wN,hN, stroke, strokeW, fill}
   *  line:  {id, kind:'line', x1N,y1N,x2N,y2N, stroke, strokeW}
   *  arrow: {id, kind:'arrow', x1N,y1N,x2N,y2N, stroke, strokeW}
   *  emoji: {id, kind:'emoji', xN,yN, emoji, size}   (export as PNG)
   */
  const state = { items: [], activeIndex: -1 };

  // reorder
  let dragFromIndex = -1;

  // modes/tools
  const TOOL = { SELECT:'select', TEXT:'text', RECT:'rect', CIRCLE:'circle', LINE:'line', ARROW:'arrow', SMILEY:'smiley', CROP:'crop' };
  let tool = TOOL.SELECT;

  // selection
  let selectedId = null;

  // preview meta
  const previewMeta = {
    kind: null, // 'pdf'|'img'
    canvasW: 0, canvasH: 0,
    pdfPtsW: 0, pdfPtsH: 0,
    imgNatW: 0, imgNatH: 0
  };

  // crop UI (canvas coords)
  let cropUI = { x:40, y:40, w:200, h:260, dragging:false, resizing:false, dx:0, dy:0 };

  // draw tool temp
  let drawTemp = null; // {kind, startX, startY, ...} in canvas coords

  // render token
  let renderToken = 0;

  // ---------- DOM ----------
  const fileInput = document.getElementById('fileInput');
  const dropZone = document.getElementById('dropZone');
  const thumbs = document.getElementById('thumbs');
  const statusEl = document.getElementById('status');
  const pageInfoEl = document.getElementById('pageInfo');

  const canvasWrap = document.getElementById('canvasWrap');
  const previewCanvas = document.getElementById('previewCanvas');
  const svgOverlay = document.getElementById('svgOverlay');
  const cropBoxEl = document.getElementById('cropBox');
  const hintEl = document.getElementById('hint');

  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const delPageBtn = document.getElementById('delPageBtn');

  const toolSelectBtn = document.getElementById('toolSelectBtn');
  const toolTextBtn = document.getElementById('toolTextBtn');
  const toolRectBtn = document.getElementById('toolRectBtn');
  const toolCircleBtn = document.getElementById('toolCircleBtn');
  const toolLineBtn = document.getElementById('toolLineBtn');
  const toolArrowBtn = document.getElementById('toolArrowBtn');
  const toolSmileyBtn = document.getElementById('toolSmileyBtn');

  const modeCropBtn = document.getElementById('modeCropBtn');
  const applyCropBtn = document.getElementById('applyCropBtn');
  const resetCropBtn = document.getElementById('resetCropBtn');

  const delAnnotBtn = document.getElementById('delAnnotBtn');

  // properties panel
  const propsPanel = document.getElementById('propsPanel');
  const propsKind = document.getElementById('propsKind');
  const propsText = document.getElementById('propsText');
  const propsStrokeFill = document.getElementById('propsStrokeFill');
  const propsEmoji = document.getElementById('propsEmoji');

  const textValue = document.getElementById('textValue');
  const textSize = document.getElementById('textSize');
  const textColor = document.getElementById('textColor');

  const strokeColor = document.getElementById('strokeColor');
  const strokeWidth = document.getElementById('strokeWidth');
  const fillMode = document.getElementById('fillMode');
  const fillColorWrap = document.getElementById('fillColorWrap');
  const fillColor = document.getElementById('fillColor');

  const emojiSelect = document.getElementById('emojiSelect');
  const emojiSize = document.getElementById('emojiSize');

  // ---------- UTILS ----------
  const clamp = (n,a,b) => Math.max(a, Math.min(b,n));
  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  function getActiveItem(){
    const i = state.activeIndex;
    if (i < 0 || i >= state.items.length) return null;
    return state.items[i];
  }
  function ensureArrays(item){
    if (!item.annots) item.annots = [];
  }

  function setStatus(){
    statusEl.textContent = state.items.length ? `${state.items.length} page(s) dans le montage` : 'Aucun document charg√©';
    pageInfoEl.textContent = (state.activeIndex >= 0) ? `Page montage : ${state.activeIndex+1}` : '‚Äî';
    applyCropBtn.disabled = !(getActiveItem() && tool === TOOL.CROP);
    resetCropBtn.disabled = !getActiveItem();
  }

  function setTool(next){
    tool = next;

    // toggle button styles
    const on = (btn, isOn) => btn.classList.toggle('toggleOn', isOn);
    on(toolSelectBtn, tool===TOOL.SELECT);
    on(toolTextBtn, tool===TOOL.TEXT);
    on(toolRectBtn, tool===TOOL.RECT);
    on(toolCircleBtn, tool===TOOL.CIRCLE);
    on(toolLineBtn, tool===TOOL.LINE);
    on(toolArrowBtn, tool===TOOL.ARROW);
    on(toolSmileyBtn, tool===TOOL.SMILEY);
    on(modeCropBtn, tool===TOOL.CROP);

    if (tool !== TOOL.SELECT) {
      // leaving selection tool still keeps selection, but no drag handles except select
    }

    // crop overlay
    if (tool === TOOL.CROP && getActiveItem()) showCropOverlay();
    else hideCropOverlay();

    // hints
    if (!getActiveItem()) {
      hintEl.textContent = "Charge un fichier pour afficher l‚Äôaper√ßu.";
    } else {
      hintEl.textContent =
        tool===TOOL.SELECT ? "S√©lection : clique un objet, d√©place-le. Double-clic sur un texte pour l‚Äô√©diter."
        : tool===TOOL.TEXT ? "Texte : clique pour placer. Double-clic ensuite pour √©diter."
        : tool===TOOL.RECT ? "Carr√© : clique-glisse pour dessiner."
        : tool===TOOL.CIRCLE ? "Rond : clique-glisse pour dessiner."
        : tool===TOOL.LINE ? "Ligne : clique-glisse pour dessiner."
        : tool===TOOL.ARROW ? "Fl√®che : clique-glisse pour dessiner."
        : tool===TOOL.SMILEY ? "Smiley : clique pour placer."
        : tool===TOOL.CROP ? "Rogner : ajuste le rectangle puis clique ‚ÄúAppliquer‚Äù."
        : "‚Äî";
    }

    applyCropBtn.disabled = !(getActiveItem() && tool===TOOL.CROP);
    delAnnotBtn.disabled = !selectedId;

    renderSvgOverlay(); // refresh selection visuals
  }

  function downloadBytes(bytes, filename){
    const blob = new Blob([bytes], { type:'application/pdf' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename || 'export.pdf';
    a.click();
    URL.revokeObjectURL(url);
  }

  function fileToDataUrl(file){
    return new Promise((resolve,reject)=>{
      const r = new FileReader();
      r.onload = () => resolve(r.result);
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

  function moveItem(from,to){
    from = clamp(from,0,state.items.length-1);
    to = clamp(to,0,state.items.length-1);
    if (from === to) return;
    const [moved] = state.items.splice(from,1);
    state.items.splice(to,0,moved);

    if (state.activeIndex === from) state.activeIndex = to;
    else if (from < state.activeIndex && to >= state.activeIndex) state.activeIndex -= 1;
    else if (from > state.activeIndex && to <= state.activeIndex) state.activeIndex += 1;
  }

  function getCanvasPos(e){
    const rect = previewCanvas.getBoundingClientRect();
    const scaleX = previewCanvas.width / rect.width;
    const scaleY = previewCanvas.height / rect.height;
    return { x:(e.clientX - rect.left)*scaleX, y:(e.clientY - rect.top)*scaleY };
  }

  // Visible rect in canvas coords (full canvas, or mapped crop)
  function getVisibleRectCanvas(item){
    const cw = previewMeta.canvasW, ch = previewMeta.canvasH;
    if (!item || !item.crop) return { x:0, y:0, w:cw, h:ch };

    if (item.type === 'pdf') {
      const pw = previewMeta.pdfPtsW, ph = previewMeta.pdfPtsH;
      const { left,bottom,right,top } = item.crop;

      const x = (left / pw) * cw;
      const w = ((right - left) / pw) * cw;

      const y = ((ph - top) / ph) * ch;
      const h = ((top - bottom) / ph) * ch;

      return { x, y, w, h };
    } else {
      const iw = previewMeta.imgNatW, ih = previewMeta.imgNatH;
      const { x:ix, y:iy, w:iw2, h:ih2 } = item.crop;
      const x = (ix / iw) * cw;
      const y = (iy / ih) * ch;
      const w = (iw2 / iw) * cw;
      const h = (ih2 / ih) * ch;
      return { x, y, w, h };
    }
  }

  // Visible rect in PDF points (for export)
  function getVisibleRectPdfPts(page, cropPts){
    if (!cropPts) return { x0:0, y0:0, w: page.getWidth(), h: page.getHeight() };
    return { x0: cropPts.left, y0: cropPts.bottom, w: (cropPts.right-cropPts.left), h: (cropPts.top-cropPts.bottom) };
  }

  // ---------- IMPORT ----------
  fileInput.addEventListener('change', async (e)=>{
    await addFiles([...(e.target.files||[])]);
    fileInput.value = '';
  });

  dropZone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropZone.style.borderColor='#2b5cff'; });
  dropZone.addEventListener('dragleave', ()=>{ dropZone.style.borderColor='#3b4257'; });
  dropZone.addEventListener('drop', async (e)=>{
    e.preventDefault(); dropZone.style.borderColor='#3b4257';
    await addFiles([...(e.dataTransfer.files||[])]);
  });

  async function addFiles(files){
    for (const file of files){
      const isPdf = file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf');

      if (isPdf){
        const ab = await file.arrayBuffer();
        const srcPdfU8 = new Uint8Array(ab); // master buffer (never detached)
        await addPdfPages(srcPdfU8, file.name);
      } else if (file.type.startsWith('image/')){
        const dataUrl = await fileToDataUrl(file);
        state.items.push({ type:'img', name:file.name, dataUrl, crop:null, annots:[] });
      }
    }
    if (state.activeIndex === -1 && state.items.length) state.activeIndex = 0;
    selectedId = null;
    await renderAll();
    setTool(tool);
  }

  async function addPdfPages(srcPdfU8, filename){
    const loadingTask = pdfjsLib.getDocument({ data: srcPdfU8.slice(0) }); // pass copy to PDF.js
    const pdf = await loadingTask.promise;
    for (let i=0; i<pdf.numPages; i++){
      state.items.push({ type:'pdf', name:filename, srcPdfU8, pageIndex:i, crop:null, annots:[] });
    }
  }

  // ---------- ACTIONS ----------
  clearBtn.addEventListener('click', async ()=>{
    state.items = [];
    state.activeIndex = -1;
    selectedId = null;
    await renderAll();
    setTool(TOOL.SELECT);
  });

  delPageBtn.addEventListener('click', async ()=>{
    const i = state.activeIndex;
    if (i < 0) return;
    state.items.splice(i,1);
    state.activeIndex = clamp(i,0,state.items.length-1);
    if (!state.items.length) state.activeIndex = -1;
    selectedId = null;
    await renderAll();
    setTool(tool);
  });

  delAnnotBtn.addEventListener('click', async ()=>{
    const item = getActiveItem();
    if (!item || !selectedId) return;
    ensureArrays(item);
    item.annots = item.annots.filter(a => a.id !== selectedId);
    selectedId = null;
    await renderAll();
    setTool(tool);
  });

  // tool buttons
  toolSelectBtn.addEventListener('click', ()=>setTool(TOOL.SELECT));
  toolTextBtn.addEventListener('click', ()=>setTool(TOOL.TEXT));
  toolRectBtn.addEventListener('click', ()=>setTool(TOOL.RECT));
  toolCircleBtn.addEventListener('click', ()=>setTool(TOOL.CIRCLE));
  toolLineBtn.addEventListener('click', ()=>setTool(TOOL.LINE));
  toolArrowBtn.addEventListener('click', ()=>setTool(TOOL.ARROW));
  toolSmileyBtn.addEventListener('click', ()=>setTool(TOOL.SMILEY));

  modeCropBtn.addEventListener('click', ()=>{
    setTool(tool === TOOL.CROP ? TOOL.SELECT : TOOL.CROP);
  });

  applyCropBtn.addEventListener('click', async ()=>{
    const item = getActiveItem();
    if (!item) return;

    const cw = previewMeta.canvasW, ch = previewMeta.canvasH;
    const x = clamp(cropUI.x, 0, cw-1);
    const y = clamp(cropUI.y, 0, ch-1);
    const w = clamp(cropUI.w, 1, cw-x);
    const h = clamp(cropUI.h, 1, ch-y);

    if (previewMeta.kind === 'pdf'){
      const pw = previewMeta.pdfPtsW, ph = previewMeta.pdfPtsH;
      const left = (x / cw) * pw;
      const right = ((x+w) / cw) * pw;
      const top = ph - (y / ch) * ph;
      const bottom = ph - ((y+h) / ch) * ph;
      item.crop = { left, bottom, right, top };
    } else if (previewMeta.kind === 'img'){
      const iw = previewMeta.imgNatW, ih = previewMeta.imgNatH;
      const ix = (x / cw) * iw;
      const iy = (y / ch) * ih;
      const iw2 = (w / cw) * iw;
      const ih2 = (h / ch) * ih;
      item.crop = { x:ix, y:iy, w:iw2, h:ih2 };
    }

    await renderAll();
    setTool(TOOL.SELECT);
  });

  resetCropBtn.addEventListener('click', async ()=>{
    const item = getActiveItem();
    if (!item) return;
    item.crop = null;
    await renderAll();
    setTool(tool);
  });

  // ---------- PROPS BINDINGS ----------
  function showPropsForSelection(){
    const item = getActiveItem();
    if (!item || !selectedId) {
      propsPanel.style.display = 'none';
      delAnnotBtn.disabled = true;
      return;
    }
    ensureArrays(item);
    const a = item.annots.find(x => x.id === selectedId);
    if (!a) {
      propsPanel.style.display = 'none';
      delAnnotBtn.disabled = true;
      return;
    }

    delAnnotBtn.disabled = false;
    propsPanel.style.display = 'flex';
    propsKind.textContent = a.kind.toUpperCase();

    propsText.style.display = 'none';
    propsStrokeFill.style.display = 'none';
    propsEmoji.style.display = 'none';

    if (a.kind === 'text') {
      propsText.style.display = 'flex';
      textValue.value = a.text || '';
      textSize.value = a.size || 18;
      textColor.value = a.color || '#ffffff';
    }

    if (a.kind === 'rect' || a.kind === 'circle' || a.kind === 'line' || a.kind === 'arrow') {
      propsStrokeFill.style.display = 'flex';
      strokeColor.value = a.stroke || '#2b5cff';
      strokeWidth.value = a.strokeW || 3;

      if (a.kind === 'rect' || a.kind === 'circle') {
        fillMode.value = a.fill ? 'color' : 'none';
        fillColorWrap.style.display = (fillMode.value === 'color') ? 'flex' : 'none';
        fillColor.value = a.fill || '#ffffff';
      } else {
        // line/arrow: no fill controls
        fillMode.value = 'none';
        fillColorWrap.style.display = 'none';
      }
    }

    if (a.kind === 'emoji') {
      propsEmoji.style.display = 'flex';
      emojiSelect.value = a.emoji || 'üôÇ';
      emojiSize.value = a.size || 64;
    }
  }

  function updateSelected(mutator){
    const item = getActiveItem();
    if (!item || !selectedId) return;
    const a = item.annots.find(x => x.id === selectedId);
    if (!a) return;
    mutator(a);
    renderSvgOverlay();
    showPropsForSelection();
  }

  textValue.addEventListener('input', ()=>updateSelected(a => { if (a.kind==='text') a.text = textValue.value; }));
  textSize.addEventListener('input', ()=>updateSelected(a => { if (a.kind==='text') a.size = safeNum(textSize.value, 18); }));
  textColor.addEventListener('input', ()=>updateSelected(a => { if (a.kind==='text') a.color = textColor.value; }));

  strokeColor.addEventListener('input', ()=>updateSelected(a => { if (a.stroke !== undefined) a.stroke = strokeColor.value; }));
  strokeWidth.addEventListener('input', ()=>updateSelected(a => { if (a.strokeW !== undefined) a.strokeW = safeNum(strokeWidth.value, 3); }));

  fillMode.addEventListener('change', ()=>{
    fillColorWrap.style.display = (fillMode.value === 'color') ? 'flex' : 'none';
    updateSelected(a => {
      if (a.kind==='rect' || a.kind==='circle') {
        a.fill = (fillMode.value === 'color') ? (fillColor.value || '#ffffff') : null;
      }
    });
  });
  fillColor.addEventListener('input', ()=>updateSelected(a => {
    if (a.kind==='rect' || a.kind==='circle') {
      if (fillMode.value === 'color') a.fill = fillColor.value;
    }
  }));

  emojiSelect.addEventListener('change', ()=>updateSelected(a => { if (a.kind==='emoji') a.emoji = emojiSelect.value; }));
  emojiSize.addEventListener('input', ()=>updateSelected(a => { if (a.kind==='emoji') a.size = safeNum(emojiSize.value, 64); }));

  function safeNum(v, fallback){
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }

  // ---------- SVG OVERLAY RENDER ----------
  function svgEl(name, attrs){
    const el = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (const [k,v] of Object.entries(attrs || {})) el.setAttribute(k, String(v));
    return el;
  }

  function hexToRgb01(hex){
    // accepts #RRGGBB
    const h = (hex || '#ffffff').replace('#','');
    const r = parseInt(h.slice(0,2),16)/255;
    const g = parseInt(h.slice(2,4),16)/255;
    const b = parseInt(h.slice(4,6),16)/255;
    return { r, g, b };
  }

  function renderSvgOverlay(){
    const item = getActiveItem();
    const cw = previewMeta.canvasW || 1;
    const ch = previewMeta.canvasH || 1;

    // match SVG to canvas pixel space
    svgOverlay.setAttribute('viewBox', `0 0 ${cw} ${ch}`);
    svgOverlay.setAttribute('preserveAspectRatio', 'none');
    svgOverlay.innerHTML = '';

    // arrow marker
    const defs = svgEl('defs');
    const marker = svgEl('marker', {
      id: 'arrowHead',
      viewBox: '0 0 10 10',
      refX: '9', refY: '5',
      markerWidth: '8', markerHeight: '8',
      orient: 'auto-start-reverse'
    });
    marker.appendChild(svgEl('path', { d:'M 0 0 L 10 5 L 0 10 z', fill:'#ffffff' }));
    defs.appendChild(marker);
    svgOverlay.appendChild(defs);

    if (!item) return;
    ensureArrays(item);

    const vis = getVisibleRectCanvas(item);

    // render objects
    for (const a of item.annots) {
      const g = svgEl('g', { 'data-id': a.id });

      // selection hit area
      g.style.cursor = (tool===TOOL.SELECT) ? 'move' : 'default';

      if (a.kind === 'text') {
        const x = vis.x + a.xN * vis.w;
        const y = vis.y + (1 - a.yN) * vis.h;

        const t = svgEl('text', {
          x, y,
          fill: a.color || '#ffffff',
          'font-size': a.size || 18,
          'font-family': 'Arial, Helvetica, sans-serif'
        });
        t.textContent = a.text || '';
        g.appendChild(t);
      }

      if (a.kind === 'emoji') {
        const x = vis.x + a.xN * vis.w;
        const y = vis.y + (1 - a.yN) * vis.h;
        const t = svgEl('text', {
          x, y,
          fill: '#ffffff',
          'font-size': a.size || 64,
          'font-family': 'Arial, Helvetica, sans-serif'
        });
        t.textContent = a.emoji || 'üôÇ';
        g.appendChild(t);
      }

      if (a.kind === 'rect' || a.kind === 'circle') {
        const x = vis.x + a.xN * vis.w;
        const yTop = vis.y + (1 - a.yN) * vis.h;
        const w = a.wN * vis.w;
        const h = a.hN * vis.h;
        const y = yTop - h;

        const common = {
          stroke: a.stroke || '#2b5cff',
          'stroke-width': a.strokeW || 3,
          fill: a.fill ? a.fill : 'none'
        };

        if (a.kind === 'rect') {
          g.appendChild(svgEl('rect', { x, y, width:w, height:h, rx:10, ry:10, ...common }));
        } else {
          g.appendChild(svgEl('ellipse', {
            cx: x + w/2,
            cy: y + h/2,
            rx: w/2,
            ry: h/2,
            ...common
          }));
        }
      }

      if (a.kind === 'line' || a.kind === 'arrow') {
        const x1 = vis.x + a.x1N * vis.w;
        const y1 = vis.y + (1 - a.y1N) * vis.h;
        const x2 = vis.x + a.x2N * vis.w;
        const y2 = vis.y + (1 - a.y2N) * vis.h;

        const line = svgEl('line', {
          x1, y1, x2, y2,
          stroke: a.stroke || '#2b5cff',
          'stroke-width': a.strokeW || 3,
          'stroke-linecap': 'round'
        });

        if (a.kind === 'arrow') {
          line.setAttribute('marker-end', 'url(#arrowHead)');
          // match marker color to stroke: easiest is set marker path fill via CSS variable not trivial;
          // for now keep white arrow head; export PDF will use stroke color.
        }
        g.appendChild(line);
      }

      // selection box
      if (a.id === selectedId) {
        const bb = computeAnnotBBoxCanvas(a, vis);
        if (bb) {
          g.appendChild(svgEl('rect', { x: bb.x, y: bb.y, width: bb.w, height: bb.h, class: 'selBox' }));
        }
      }

      svgOverlay.appendChild(g);
    }

    showPropsForSelection();
  }

  function computeAnnotBBoxCanvas(a, vis){
    // rough bbox for selection visuals
    if (a.kind === 'text' || a.kind === 'emoji') {
      const x = vis.x + a.xN * vis.w;
      const y = vis.y + (1 - a.yN) * vis.h;
      const size = a.size || 18;
      return { x: x - 2, y: y - size, w: Math.max(40, (a.text||a.emoji||'').length * (size*0.6)), h: size + 8 };
    }
    if (a.kind === 'rect' || a.kind === 'circle') {
      const x = vis.x + a.xN * vis.w;
      const yTop = vis.y + (1 - a.yN) * vis.h;
      const w = a.wN * vis.w;
      const h = a.hN * vis.h;
      const y = yTop - h;
      return { x, y, w, h };
    }
    if (a.kind === 'line' || a.kind === 'arrow') {
      const x1 = vis.x + a.x1N * vis.w;
      const y1 = vis.y + (1 - a.y1N) * vis.h;
      const x2 = vis.x + a.x2N * vis.w;
      const y2 = vis.y + (1 - a.y2N) * vis.h;
      const x = Math.min(x1,x2), y = Math.min(y1,y2);
      return { x, y, w: Math.max(10, Math.abs(x2-x1)), h: Math.max(10, Math.abs(y2-y1)) };
    }
    return null;
  }

  // ---------- SVG INTERACTION (select/move/edit/draw) ----------
  function hitAnnotIdFromEvent(e){
    const g = e.target.closest('g[data-id]');
    return g ? g.getAttribute('data-id') : null;
  }

  let dragSel = null; // {id, startPos, origAnnot...} in normalized coords
  svgOverlay.addEventListener('pointerdown', async (e)=>{
    const item = getActiveItem();
    if (!item) return;
    ensureArrays(item);

    const pos = getCanvasPos(e);
    const vis = getVisibleRectCanvas(item);

    if (tool === TOOL.CROP) return; // crop uses HTML overlay

    // SELECT tool: click object to select & drag
    if (tool === TOOL.SELECT) {
      const id = hitAnnotIdFromEvent(e);
      selectedId = id;
      renderSvgOverlay();
      if (!id) return;

      const a = item.annots.find(x => x.id === id);
      if (!a) return;

      // start dragging
      dragSel = { id, startX: pos.x, startY: pos.y, a0: JSON.parse(JSON.stringify(a)) };
      svgOverlay.setPointerCapture(e.pointerId);
      e.preventDefault();
      return;
    }

    // Drawing tools
    selectedId = null;
    renderSvgOverlay();

    if (tool === TOOL.TEXT) {
      const text = prompt("Texte :", "Texte");
      if (!text) return;
      const size = safeNum(prompt("Taille du texte :", "24"), 24);
      const color = prompt("Couleur (hex ex: #ffffff) :", "#ffffff") || "#ffffff";

      const xN = clamp((pos.x - vis.x) / vis.w, 0, 1);
      const yN = clamp(1 - ((pos.y - vis.y) / vis.h), 0, 1);

      const a = { id: uid(), kind:'text', xN, yN, text, size, color };
      item.annots.push(a);
      selectedId = a.id;
      await renderAll();
      setTool(TOOL.SELECT);
      return;
    }

    if (tool === TOOL.SMILEY) {
      const emoji = emojiSelect.value || 'üôÇ';
      const size = 72;
      const xN = clamp((pos.x - vis.x) / vis.w, 0, 1);
      const yN = clamp(1 - ((pos.y - vis.y) / vis.h), 0, 1);

      const a = { id: uid(), kind:'emoji', xN, yN, emoji, size };
      item.annots.push(a);
      selectedId = a.id;
      await renderAll();
      setTool(TOOL.SELECT);
      return;
    }

    // click-drag shapes/lines
    if ([TOOL.RECT, TOOL.CIRCLE, TOOL.LINE, TOOL.ARROW].includes(tool)) {
      drawTemp = { tool, startX: pos.x, startY: pos.y, curX: pos.x, curY: pos.y, visSnap: vis };
      svgOverlay.setPointerCapture(e.pointerId);
      e.preventDefault();
      return;
    }
  });

  svgOverlay.addEventListener('pointermove', (e)=>{
    const item = getActiveItem();
    if (!item) return;
    ensureArrays(item);

    const pos = getCanvasPos(e);
    const vis = getVisibleRectCanvas(item);

    // drag selection
    if (dragSel && tool === TOOL.SELECT) {
      const a = item.annots.find(x => x.id === dragSel.id);
      if (!a) return;

      const dx = pos.x - dragSel.startX;
      const dy = pos.y - dragSel.startY;

      // move based on kind
      if (a.kind === 'text' || a.kind === 'emoji') {
        const xCanvas0 = vis.x + dragSel.a0.xN * vis.w;
        const yCanvas0 = vis.y + (1 - dragSel.a0.yN) * vis.h;

        const xCanvas = xCanvas0 + dx;
        const yCanvas = yCanvas0 + dy;

        a.xN = clamp((xCanvas - vis.x) / vis.w, 0, 1);
        a.yN = clamp(1 - ((yCanvas - vis.y) / vis.h), 0, 1);
      } else if (a.kind === 'rect' || a.kind === 'circle') {
        const xCanvas0 = vis.x + dragSel.a0.xN * vis.w;
        const yTop0 = vis.y + (1 - dragSel.a0.yN) * vis.h;

        const xCanvas = xCanvas0 + dx;
        const yTop = yTop0 + dy;

        a.xN = clamp((xCanvas - vis.x) / vis.w, 0, 1);
        a.yN = clamp(1 - ((yTop - vis.y) / vis.h), 0, 1);
      } else if (a.kind === 'line' || a.kind === 'arrow') {
        const x1c0 = vis.x + dragSel.a0.x1N * vis.w;
        const y1c0 = vis.y + (1 - dragSel.a0.y1N) * vis.h;
        const x2c0 = vis.x + dragSel.a0.x2N * vis.w;
        const y2c0 = vis.y + (1 - dragSel.a0.y2N) * vis.h;

        const x1c = x1c0 + dx, y1c = y1c0 + dy;
        const x2c = x2c0 + dx, y2c = y2c0 + dy;

        a.x1N = clamp((x1c - vis.x) / vis.w, 0, 1);
        a.y1N = clamp(1 - ((y1c - vis.y) / vis.h), 0, 1);
        a.x2N = clamp((x2c - vis.x) / vis.w, 0, 1);
        a.y2N = clamp(1 - ((y2c - vis.y) / vis.h), 0, 1);
      }

      renderSvgOverlay();
      e.preventDefault();
      return;
    }

    // draw temp
    if (drawTemp) {
      drawTemp.curX = pos.x;
      drawTemp.curY = pos.y;

      // render a preview temporary object without committing
      renderSvgOverlay();
      renderDrawTempOverlay(item, vis);
      e.preventDefault();
    }
  });

  svgOverlay.addEventListener('pointerup', async (e)=>{
    const item = getActiveItem();
    if (!item) return;
    ensureArrays(item);

    // finish drag
    if (dragSel) {
      dragSel = null;
      showPropsForSelection();
      e.preventDefault();
      return;
    }

    // finish draw
    if (drawTemp) {
      const t = drawTemp;
      drawTemp = null;

      const vis = t.visSnap || getVisibleRectCanvas(item);
      const x0 = t.startX, y0 = t.startY;
      const x1 = t.curX, y1 = t.curY;

      // create annot in normalized coords within vis
      const xMin = Math.min(x0,x1), xMax = Math.max(x0,x1);
      const yMin = Math.min(y0,y1), yMax = Math.max(y0,y1);

      const stroke = strokeColor.value || '#2b5cff';
      const strokeW = safeNum(strokeWidth.value, 3);

      let newA = null;

      if (t.tool === TOOL.RECT || t.tool === TOOL.CIRCLE) {
        const xN = clamp((xMin - vis.x)/vis.w, 0, 1);
        const yTopN = clamp(1 - ((yMin - vis.y)/vis.h), 0, 1);
        const wN = clamp((xMax - xMin)/vis.w, 0.001, 1);
        const hN = clamp((yMax - yMin)/vis.h, 0.001, 1);

        const fill = (fillMode.value === 'color') ? (fillColor.value || '#ffffff') : null;

        newA = {
          id: uid(),
          kind: (t.tool === TOOL.RECT) ? 'rect' : 'circle',
          xN, yN: yTopN, wN, hN,
          stroke, strokeW,
          fill
        };
      }

      if (t.tool === TOOL.LINE || t.tool === TOOL.ARROW) {
        const x1N = clamp((x0 - vis.x)/vis.w, 0, 1);
        const y1N = clamp(1 - ((y0 - vis.y)/vis.h), 0, 1);
        const x2N = clamp((x1 - vis.x)/vis.w, 0, 1);
        const y2N = clamp(1 - ((y1 - vis.y)/vis.h), 0, 1);

        newA = {
          id: uid(),
          kind: (t.tool === TOOL.LINE) ? 'line' : 'arrow',
          x1N, y1N, x2N, y2N,
          stroke, strokeW
        };
      }

      if (newA) {
        item.annots.push(newA);
        selectedId = newA.id;
        await renderAll();
        setTool(TOOL.SELECT);
      } else {
        renderSvgOverlay();
      }

      e.preventDefault();
    }
  });

  // double click edit
  svgOverlay.addEventListener('dblclick', async (e)=>{
    const item = getActiveItem();
    if (!item) return;
    ensureArrays(item);

    const id = hitAnnotIdFromEvent(e);
    if (!id) return;

    selectedId = id;
    const a = item.annots.find(x => x.id === id);
    if (!a) return;

    if (a.kind === 'text') {
      const next = prompt("Modifier le texte :", a.text || "");
      if (next === null) return;
      a.text = next;
      await renderAll();
      setTool(TOOL.SELECT);
      return;
    }

    if (a.kind === 'emoji') {
      const next = prompt("Modifier le smiley (ex: üôÇ) :", a.emoji || "üôÇ");
      if (next === null || !next) return;
      a.emoji = next;
      await renderAll();
      setTool(TOOL.SELECT);
      return;
    }
  });

  function renderDrawTempOverlay(item, vis){
    if (!drawTemp) return;

    const x0 = drawTemp.startX, y0 = drawTemp.startY;
    const x1 = drawTemp.curX, y1 = drawTemp.curY;

    const stroke = strokeColor.value || '#2b5cff';
    const sw = safeNum(strokeWidth.value, 3);
    const fill = (fillMode.value === 'color') ? (fillColor.value || '#ffffff') : 'none';

    const g = svgEl('g', { 'data-temp': '1' });

    if (drawTemp.tool === TOOL.RECT || drawTemp.tool === TOOL.CIRCLE) {
      const x = Math.min(x0,x1);
      const y = Math.min(y0,y1);
      const w = Math.max(2, Math.abs(x1-x0));
      const h = Math.max(2, Math.abs(y1-y0));

      if (drawTemp.tool === TOOL.RECT) {
        g.appendChild(svgEl('rect', { x, y, width:w, height:h, rx:10, ry:10, stroke, 'stroke-width':sw, fill }));
      } else {
        g.appendChild(svgEl('ellipse', { cx:x+w/2, cy:y+h/2, rx:w/2, ry:h/2, stroke, 'stroke-width':sw, fill }));
      }
    }

    if (drawTemp.tool === TOOL.LINE || drawTemp.tool === TOOL.ARROW) {
      const line = svgEl('line', { x1:x0, y1:y0, x2:x1, y2:y1, stroke, 'stroke-width':sw, 'stroke-linecap':'round' });
      if (drawTemp.tool === TOOL.ARROW) line.setAttribute('marker-end', 'url(#arrowHead)');
      g.appendChild(line);
    }

    svgOverlay.appendChild(g);
  }

  // ---------- CROP OVERLAY (HTML) ----------
  function showCropOverlay(){
    cropBoxEl.style.display = 'block';
    positionCropOverlay();
  }
  function hideCropOverlay(){
    cropBoxEl.style.display = 'none';
  }
  function positionCropOverlay(){
    const cw = previewMeta.canvasW, ch = previewMeta.canvasH;
    cropUI.x = clamp(cropUI.x, 0, cw-1);
    cropUI.y = clamp(cropUI.y, 0, ch-1);
    cropUI.w = clamp(cropUI.w, 1, cw - cropUI.x);
    cropUI.h = clamp(cropUI.h, 1, ch - cropUI.y);

    cropBoxEl.style.left = cropUI.x + 'px';
    cropBoxEl.style.top = cropUI.y + 'px';
    cropBoxEl.style.width = cropUI.w + 'px';
    cropBoxEl.style.height = cropUI.h + 'px';
  }

  cropBoxEl.addEventListener('mousedown', (e)=>{
    if (tool !== TOOL.CROP) return;
    const isHandle = e.target && e.target.classList.contains('br');
    const pos = getCanvasPos(e);

    if (isHandle){
      cropUI.resizing = true;
    } else {
      cropUI.dragging = true;
      cropUI.dx = pos.x - cropUI.x;
      cropUI.dy = pos.y - cropUI.y;
    }
    e.preventDefault();
  });

  window.addEventListener('mousemove', (e)=>{
    if (tool !== TOOL.CROP) return;
    if (!cropUI.dragging && !cropUI.resizing) return;

    const pos = getCanvasPos(e);
    const cw = previewMeta.canvasW, ch = previewMeta.canvasH;

    if (cropUI.dragging){
      cropUI.x = clamp(pos.x - cropUI.dx, 0, cw - cropUI.w);
      cropUI.y = clamp(pos.y - cropUI.dy, 0, ch - cropUI.h);
    }
    if (cropUI.resizing){
      cropUI.w = clamp(pos.x - cropUI.x, 30, cw - cropUI.x);
      cropUI.h = clamp(pos.y - cropUI.y, 30, ch - cropUI.y);
    }
    positionCropOverlay();
  });

  window.addEventListener('mouseup', ()=>{
    cropUI.dragging = false;
    cropUI.resizing = false;
  });

  // ---------- RENDER (thumbs + preview) ----------
  async function renderAll(){
    setStatus();
    await renderThumbs();
    await renderPreview();
    renderSvgOverlay();
    showPropsForSelection();
  }

  async function renderThumbs(){
    thumbs.innerHTML = '';

    for (let i=0; i<state.items.length; i++){
      const item = state.items[i];
      ensureArrays(item);

      const card = document.createElement('div');
      card.className = 'thumb' + (i === state.activeIndex ? ' active' : '');
      card.draggable = true;

      card.addEventListener('click', async ()=>{
        state.activeIndex = i;
        selectedId = null;
        await renderAll();
        setTool(tool);
      });

      // drag reorder
      card.addEventListener('dragstart', (e)=>{
        dragFromIndex = i;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(i));
      });
      card.addEventListener('dragover', (e)=>{
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        card.style.outline = '2px solid #2b5cff';
      });
      card.addEventListener('dragleave', ()=>{ card.style.outline = ''; });
      card.addEventListener('drop', async (e)=>{
        e.preventDefault();
        card.style.outline = '';
        const from = dragFromIndex >= 0 ? dragFromIndex : Number(e.dataTransfer.getData('text/plain'));
        const to = i;
        dragFromIndex = -1;
        if (Number.isNaN(from) || from === to) return;
        moveItem(from, to);
        await renderAll();
        setTool(tool);
      });

      const left = document.createElement('div');
      const right = document.createElement('div');
      right.className = 'meta';

      if (item.type === 'img'){
        const img = document.createElement('img');
        img.src = item.dataUrl;
        left.appendChild(img);

        right.innerHTML = `
          <div><b>Image</b></div>
          <div class="small">${escapeHtml(item.name || '')}</div>
          <div class="small">Montage : ${i+1}</div>
          <div class="small">${item.crop ? '‚úÇÔ∏è rogn√© ' : ''}${item.annots.length ? 'üñäÔ∏è annot' : ''}</div>
        `;
      } else {
        const c = document.createElement('canvas');
        c.width = 144; c.height = 192;
        left.appendChild(c);

        right.innerHTML = `
          <div><b>PDF</b></div>
          <div class="small">${escapeHtml(item.name || '')}</div>
          <div class="small">Source : ${item.pageIndex+1} ‚Ä¢ Montage : ${i+1}</div>
          <div class="small">${item.crop ? '‚úÇÔ∏è rogn√© ' : ''}${item.annots.length ? 'üñäÔ∏è annot' : ''}</div>
        `;

        try {
          await renderPdfPageToCanvas(item.srcPdfU8, item.pageIndex, c, 0.25, 144);
        } catch(e) {
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#111'; ctx.fillRect(0,0,c.width,c.height);
          ctx.fillStyle = '#bbb'; ctx.fillText('PDF', 10, 20);
        }
      }

      card.appendChild(left);
      card.appendChild(right);
      thumbs.appendChild(card);
    }
  }

  async function renderPreview(){
    const myToken = ++renderToken;
    const item = getActiveItem();
    const ctx = previewCanvas.getContext('2d');

    if (!item){
      previewMeta.kind = null;
      previewCanvas.width = 1; previewCanvas.height = 1;
      ctx.clearRect(0,0,1,1);
      hintEl.textContent = 'Charge un fichier pour afficher l‚Äôaper√ßu.';
      hideCropOverlay();
      return;
    }

    hintEl.textContent = 'Chargement aper√ßu‚Ä¶';

    if (item.type === 'img'){
      const img = await dataUrlToImage(item.dataUrl);
      if (myToken !== renderToken) return;

      const maxW = 900;
      const scale = Math.min(1, maxW / img.naturalWidth);
      const cw = Math.floor(img.naturalWidth * scale);
      const ch = Math.floor(img.naturalHeight * scale);

      previewCanvas.width = cw; previewCanvas.height = ch;

      previewMeta.kind = 'img';
      previewMeta.canvasW = cw; previewMeta.canvasH = ch;
      previewMeta.imgNatW = img.naturalWidth; previewMeta.imgNatH = img.naturalHeight;

      ctx.clearRect(0,0,cw,ch);
      ctx.drawImage(img, 0, 0, cw, ch);

      // initialize crop box based on existing crop or default
      const vis = getVisibleRectCanvas(item);
      cropUI = item.crop ? { ...vis, dragging:false, resizing:false, dx:0, dy:0 } : defaultCrop(cw,ch);

      hintEl.textContent = '';
    } else {
      const meta = await renderPdfPageToCanvas(item.srcPdfU8, item.pageIndex, previewCanvas, 1.4, 900);
      if (myToken !== renderToken) return;

      previewMeta.kind = 'pdf';
      previewMeta.canvasW = meta.canvasW; previewMeta.canvasH = meta.canvasH;
      previewMeta.pdfPtsW = meta.pdfPtsW; previewMeta.pdfPtsH = meta.pdfPtsH;

      // initialize crop box based on existing crop or default
      if (item.crop) {
        // convert crop pts to canvas rect
        const pw = previewMeta.pdfPtsW, ph = previewMeta.pdfPtsH;
        const cw = previewMeta.canvasW, ch = previewMeta.canvasH;
        const x = (item.crop.left / pw) * cw;
        const w = ((item.crop.right-item.crop.left)/pw)*cw;
        const y = ((ph - item.crop.top)/ph)*ch;
        const h = ((item.crop.top-item.crop.bottom)/ph)*ch;
        cropUI = { x,y,w,h, dragging:false, resizing:false, dx:0, dy:0 };
      } else {
        cropUI = defaultCrop(previewMeta.canvasW, previewMeta.canvasH);
      }

      hintEl.textContent = '';
    }

    // sync overlay sizes
    syncOverlayToCanvas();

    if (tool === TOOL.CROP) showCropOverlay(); else hideCropOverlay();
  }

  function defaultCrop(cw,ch){
    return { x:40, y:40, w: Math.max(120, cw-80), h: Math.max(160, ch-80), dragging:false, resizing:false, dx:0, dy:0 };
  }

  function syncOverlayToCanvas(){
    // ensure svg and crop overlay align with canvas size (canvas pixels)
    const cw = previewMeta.canvasW || 1;
    const ch = previewMeta.canvasH || 1;

    // set svg to cover the canvas exactly in CSS pixels via absolute sizing; viewBox is in px
    svgOverlay.setAttribute('viewBox', `0 0 ${cw} ${ch}`);
    svgOverlay.style.width = '100%';
    svgOverlay.style.height = '100%';

    // crop box: already in canvas coords, use pixels
    positionCropOverlay();
  }

  async function renderPdfPageToCanvas(pdfU8, pageIndex, canvas, baseScale, maxW){
    const loadingTask = pdfjsLib.getDocument({ data: pdfU8.slice(0) }); // pass copy (prevents detached ArrayBuffer)
    const pdf = await loadingTask.promise;
    const page = await pdf.getPage(pageIndex + 1);

    const view = page.view; // [xMin,yMin,xMax,yMax] points
    const pdfPtsW = (view[2]-view[0]);
    const pdfPtsH = (view[3]-view[1]);

    let viewport = page.getViewport({ scale: baseScale });
    const s = Math.min(1, (maxW || 900) / viewport.width);
    viewport = page.getViewport({ scale: baseScale * s });

    const ctx = canvas.getContext('2d');
    canvas.width = Math.floor(viewport.width);
    canvas.height = Math.floor(viewport.height);

    await page.render({ canvasContext: ctx, viewport }).promise;
    return { canvasW: canvas.width, canvasH: canvas.height, pdfPtsW, pdfPtsH };
  }

  // ---------- EXPORT ----------
  exportBtn.addEventListener('click', async ()=>{
    if (!state.items.length) return;

    exportBtn.disabled = true;
    exportBtn.textContent = 'Export...';

    try{
      const out = await PDFDocument.create();
      const font = await out.embedFont(StandardFonts.Helvetica);
      const pdfCache = new Map(); // srcPdfU8 -> PDFDocument

      for (const item of state.items){
        ensureArrays(item);

        if (item.type === 'pdf'){
          let srcDoc = pdfCache.get(item.srcPdfU8);
          if (!srcDoc){
            srcDoc = await PDFDocument.load(item.srcPdfU8);
            pdfCache.set(item.srcPdfU8, srcDoc);
          }

          const [page] = await out.copyPages(srcDoc, [item.pageIndex]);
          out.addPage(page);

          // apply crop
          if (item.crop && page.setCropBox){
            const { left,bottom,right,top } = item.crop;
            page.setCropBox(left, bottom, right-left, top-bottom);
          }

          const vis = getVisibleRectPdfPts(page, item.crop);

          // draw annots
          for (const a of item.annots){
            if (a.kind === 'text') {
              const x = vis.x0 + a.xN * vis.w;
              const y = vis.y0 + a.yN * vis.h;
              const c = hexToRgb01(a.color || '#ffffff');
              page.drawText(a.text || '', { x, y, size: a.size || 18, font, color: rgb(c.r,c.g,c.b) });
            }

            if (a.kind === 'rect' || a.kind === 'circle') {
              const x = vis.x0 + a.xN * vis.w;
              const yTop = vis.y0 + a.yN * vis.h;
              const w = a.wN * vis.w;
              const h = a.hN * vis.h;
              const y = yTop - h;

              const sc = hexToRgb01(a.stroke || '#2b5cff');
              const sw = a.strokeW || 3;

              const fill = a.fill ? hexToRgb01(a.fill) : null;

              if (a.kind === 'rect') {
                page.drawRectangle({
                  x, y, width: w, height: h,
                  borderColor: rgb(sc.r,sc.g,sc.b),
                  borderWidth: sw,
                  color: fill ? rgb(fill.r,fill.g,fill.b) : undefined,
                  opacity: fill ? 0.25 : undefined
                });
              } else {
                page.drawEllipse({
                  x: x + w/2,
                  y: y + h/2,
                  xScale: w/2,
                  yScale: h/2,
                  borderColor: rgb(sc.r,sc.g,sc.b),
                  borderWidth: sw,
                  color: fill ? rgb(fill.r,fill.g,fill.b) : undefined,
                  opacity: fill ? 0.25 : undefined
                });
              }
            }

            if (a.kind === 'line' || a.kind === 'arrow') {
              const x1 = vis.x0 + a.x1N * vis.w;
              const y1 = vis.y0 + a.y1N * vis.h;
              const x2 = vis.x0 + a.x2N * vis.w;
              const y2 = vis.y0 + a.y2N * vis.h;

              const sc = hexToRgb01(a.stroke || '#2b5cff');
              const sw = a.strokeW || 3;

              page.drawLine({
                start: { x: x1, y: y1 },
                end: { x: x2, y: y2 },
                thickness: sw,
                color: rgb(sc.r,sc.g,sc.b)
              });

              if (a.kind === 'arrow') {
                // arrow head as filled triangle
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.max(1, Math.hypot(dx, dy));
                const ux = dx / len, uy = dy / len;

                const headLen = Math.max(10, sw * 4.5);
                const headWid = Math.max(8, sw * 3.0);

                // tip at (x2,y2)
                const bx = x2 - ux * headLen;
                const by = y2 - uy * headLen;

                // perpendicular
                const px = -uy, py = ux;

                const p1 = { x: x2, y: y2 };
                const p2 = { x: bx + px * headWid/2, y: by + py * headWid/2 };
                const p3 = { x: bx - px * headWid/2, y: by - py * headWid/2 };

                page.drawPolygon([p1,p2,p3], { color: rgb(sc.r,sc.g,sc.b), borderWidth: 0 });
              }
            }

            if (a.kind === 'emoji') {
              // Export emoji as PNG (robust: works even if PDF font lacks emoji)
              const pngDataUrl = emojiToPngDataUrl(a.emoji || 'üôÇ', a.size || 64);
              const img = await out.embedPng(pngDataUrl);

              const x = vis.x0 + a.xN * vis.w;
              const y = vis.y0 + a.yN * vis.h;

              // pdf-lib draws images from bottom-left; use size mapped to points
              const pxSize = a.size || 64;
              const w = Math.min(vis.w, pxSize);
              const h = Math.min(vis.h, pxSize);

              page.drawImage(img, { x, y, width: w, height: h });
            }
          }

        } else if (item.type === 'img') {
          // apply crop to image first, then embed PNG always
          const imgEl = await dataUrlToImage(item.dataUrl);

          const crop = item.crop
            ? {
                x: clamp(item.crop.x, 0, imgEl.naturalWidth),
                y: clamp(item.crop.y, 0, imgEl.naturalHeight),
                w: clamp(item.crop.w, 1, imgEl.naturalWidth - item.crop.x),
                h: clamp(item.crop.h, 1, imgEl.naturalHeight - item.crop.y),
              }
            : { x:0, y:0, w:imgEl.naturalWidth, h:imgEl.naturalHeight };

          const pngDataUrl = cropImageToPngDataUrl(imgEl, crop);
          const embedded = await out.embedPng(pngDataUrl);

          // page sized to image (scaled to ~A4 width max)
          const maxW = 595;
          const scale = Math.min(1, maxW / embedded.width);
          const w = embedded.width * scale;
          const h = embedded.height * scale;

          const page = out.addPage([w, h]);
          page.drawImage(embedded, { x:0, y:0, width:w, height:h });

          // vis for images is whole page (after crop)
          const vis = { x0:0, y0:0, w, h };

          for (const a of item.annots){
            if (a.kind === 'text') {
              const x = vis.x0 + a.xN * vis.w;
              const y = vis.y0 + a.yN * vis.h;
              const c = hexToRgb01(a.color || '#ffffff');
              page.drawText(a.text || '', { x, y, size: a.size || 18, font, color: rgb(c.r,c.g,c.b) });
            }

            if (a.kind === 'rect' || a.kind === 'circle') {
              const x = vis.x0 + a.xN * vis.w;
              const yTop = vis.y0 + a.yN * vis.h;
              const ww = a.wN * vis.w;
              const hh = a.hN * vis.h;
              const y = yTop - hh;

              const sc = hexToRgb01(a.stroke || '#2b5cff');
              const sw = a.strokeW || 3;
              const fill = a.fill ? hexToRgb01(a.fill) : null;

              if (a.kind === 'rect') {
                page.drawRectangle({
                  x, y, width: ww, height: hh,
                  borderColor: rgb(sc.r,sc.g,sc.b),
                  borderWidth: sw,
                  color: fill ? rgb(fill.r,fill.g,fill.b) : undefined,
                  opacity: fill ? 0.25 : undefined
                });
              } else {
                page.drawEllipse({
                  x: x + ww/2,
                  y: y + hh/2,
                  xScale: ww/2,
                  yScale: hh/2,
                  borderColor: rgb(sc.r,sc.g,sc.b),
                  borderWidth: sw,
                  color: fill ? rgb(fill.r,fill.g,fill.b) : undefined,
                  opacity: fill ? 0.25 : undefined
                });
              }
            }

            if (a.kind === 'line' || a.kind === 'arrow') {
              const x1 = vis.x0 + a.x1N * vis.w;
              const y1 = vis.y0 + a.y1N * vis.h;
              const x2 = vis.x0 + a.x2N * vis.w;
              const y2 = vis.y0 + a.y2N * vis.h;

              const sc = hexToRgb01(a.stroke || '#2b5cff');
              const sw = a.strokeW || 3;

              page.drawLine({
                start: { x: x1, y: y1 },
                end: { x: x2, y: y2 },
                thickness: sw,
                color: rgb(sc.r,sc.g,sc.b)
              });

              if (a.kind === 'arrow') {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const len = Math.max(1, Math.hypot(dx, dy));
                const ux = dx / len, uy = dy / len;

                const headLen = Math.max(10, sw * 4.5);
                const headWid = Math.max(8, sw * 3.0);

                const bx = x2 - ux * headLen;
                const by = y2 - uy * headLen;

                const px = -uy, py = ux;

                const p1 = { x: x2, y: y2 };
                const p2 = { x: bx + px * headWid/2, y: by + py * headWid/2 };
                const p3 = { x: bx - px * headWid/2, y: by - py * headWid/2 };

                page.drawPolygon([p1,p2,p3], { color: rgb(sc.r,sc.g,sc.b), borderWidth: 0 });
              }
            }

            if (a.kind === 'emoji') {
              const pngDataUrl2 = emojiToPngDataUrl(a.emoji || 'üôÇ', a.size || 64);
              const img = await out.embedPng(pngDataUrl2);

              const x = vis.x0 + a.xN * vis.w;
              const y = vis.y0 + a.yN * vis.h;
              const pxSize = a.size || 64;
              const ww = Math.min(vis.w, pxSize);
              const hh = Math.min(vis.h, pxSize);

              page.drawImage(img, { x, y, width: ww, height: hh });
            }
          }
        }
      }

      const bytes = await out.save();
      downloadBytes(bytes, 'export.pdf');
    } catch(err){
      alert('Erreur export : ' + (err?.message || err));
      console.error(err);
    } finally {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Exporter PDF';
    }
  });

  // ---------- IMAGE/EMOJI HELPERS ----------
  function dataUrlToImage(dataUrl){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=>resolve(img);
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function cropImageToPngDataUrl(imgEl, crop){
    const c = document.createElement('canvas');
    c.width = Math.max(1, Math.floor(crop.w));
    c.height = Math.max(1, Math.floor(crop.h));
    const ctx = c.getContext('2d');
    ctx.drawImage(imgEl, crop.x, crop.y, crop.w, crop.h, 0, 0, c.width, c.height);
    return c.toDataURL('image/png');
  }

  function emojiToPngDataUrl(emoji, sizePx){
    const s = Math.max(24, Math.floor(sizePx));
    const c = document.createElement('canvas');
    c.width = s; c.height = s;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,s,s);
    ctx.font = `${Math.floor(s*0.9)}px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(emoji, s/2, s/2);
    return c.toDataURL('image/png');
  }

  function escapeHtml(s){
    return String(s||'').replace(/[&<>"']/g, (c)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[c]));
  }

  // ---------- INIT ----------
  setTool(TOOL.SELECT);
  renderAll();

})();
</script>
</body>
</html>
