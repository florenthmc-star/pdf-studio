<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arrow Studio (Local) — Flèches stylées + Export PDF</title>

  <!-- pdf-lib -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>

  <style>
    :root { font-family: Arial, Helvetica, sans-serif; }
    body { margin:0; background:#0f1115; color:#e7e7e7; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 14px; }
    .top {
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:space-between;
      border:1px solid #242833; background:#121521; border-radius:16px; padding:12px;
    }
    .left, .right { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .btn {
      background:#1e2433; color:#e7e7e7; border:1px solid #2a3144;
      padding:8px 10px; border-radius:12px; cursor:pointer; font-size:13px; user-select:none;
    }
    .btn:hover { background:#242c3f; }
    .btn.primary { background:#2b5cff; border-color:#2b5cff; }
    .btn.danger { background:#3a1e22; border-color:#5a2a32; }
    .btn.toggleOn { outline:2px solid #2b5cff; }
    .chip { border:1px solid #2a3144; background:#171c29; border-radius:999px; padding:6px 10px; font-size:12px; color:#b9c0d4; }
    .field {
      display:flex; gap:8px; align-items:center;
      border:1px solid #242833; background:#0b0d12; border-radius:14px;
      padding:8px 10px;
    }
    label { font-size:12px; color:#b9c0d4; display:flex; align-items:center; gap:8px; }
    select, input[type="range"]{
      background:#111522; color:#e7e7e7; border:1px solid #2a3144; border-radius:10px;
      padding:6px 8px; font-size:12px;
    }
    input[type="color"] { width:40px; height:32px; border:none; background:transparent; padding:0; cursor:pointer; }
    .stage {
      margin-top:12px;
      border:1px solid #242833; background:#0b0d12; border-radius:16px;
      padding:14px;
    }
    .canvasWrap { position:relative; display:inline-block; width:100%; }
    #bgCanvas { width:100%; height:auto; border-radius:12px; background:#ffffff; display:block; }
    #svgOverlay {
      position:absolute; left:0; top:0; width:100%; height:100%;
      pointer-events:auto; touch-action:none;
    }
    .hint { margin-top:10px; color:#98a2bd; font-size:12px; line-height:1.4; }
    .selBox { fill:none; stroke:#2b5cff; stroke-width:2; stroke-dasharray:7 5; }
    .handleDot { fill:#2b5cff; stroke:rgba(0,0,0,.4); stroke-width:2; cursor:pointer; }
    .ghost { opacity:0.7; }
    .gridNote { color:#98a2bd; font-size:12px; }
    kbd { background:#171c29; border:1px solid #2a3144; border-bottom-width:2px; padding:2px 6px; border-radius:8px; font-size:12px; color:#e7e7e7; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="left">
        <button class="btn toggleOn" id="toolArrow">Outil Flèche</button>
        <button class="btn" id="toolSelect">Sélection</button>

        <div class="field">
          <label>Style
            <select id="styleSel">
              <option value="straight">Droite</option>
              <option value="curved">Courbée</option>
              <option value="double">Double-pointe</option>
            </select>
          </label>
        </div>

        <div class="field">
          <label>Épaisseur
            <input id="thickness" type="range" min="2" max="30" value="8" />
            <span class="chip" id="thVal">8</span>
          </label>
        </div>

        <div class="field">
          <label>Couleur <input id="color" type="color" value="#2b5cff"></label>
        </div>

        <div class="field">
          <label>Snap
            <select id="snapMode">
              <option value="on">ON (grille + points)</option>
              <option value="grid">Grille seulement</option>
              <option value="off">OFF</option>
            </select>
          </label>
          <span class="gridNote">Grille: 10px • Maintiens <kbd>Shift</kbd> = pas de snap</span>
        </div>
      </div>

      <div class="right">
        <span class="chip" id="selInfo">Aucune sélection</span>
        <button class="btn" id="delBtn" disabled>Supprimer</button>
        <button class="btn danger" id="clearBtn">Vider</button>
        <button class="btn primary" id="exportBtn">Exporter PDF</button>
      </div>
    </div>

    <div class="stage">
      <div class="canvasWrap" id="canvasWrap">
        <!-- Background canvas (white page) -->
        <canvas id="bgCanvas" width="1000" height="600"></canvas>
        <!-- SVG overlay for interactive arrows -->
        <svg id="svgOverlay"></svg>
      </div>

      <div class="hint">
        • Dessiner : sélectionne <b>Outil Flèche</b> puis clique-glisse.<br>
        • Modifier : <b>Sélection</b> → glisser la flèche / poignées (extrémités). En mode <b>Courbée</b> tu as aussi la poignée centrale.<br>
        • Copier/Coller : <kbd>Ctrl</kbd>+<kbd>C</kbd> puis <kbd>Ctrl</kbd>+<kbd>V</kbd> (duplique en décalé).<br>
        • Alignement automatique : <b>Snap</b> (grille + points) — maintiens <kbd>Shift</kbd> pour désactiver temporairement.
      </div>
    </div>
  </div>

<script>
(() => {
  const { PDFDocument, rgb } = PDFLib;

  // ------- DOM
  const bgCanvas = document.getElementById('bgCanvas');
  const ctx = bgCanvas.getContext('2d');
  const svg = document.getElementById('svgOverlay');
  const wrap = document.getElementById('canvasWrap');

  const toolArrowBtn = document.getElementById('toolArrow');
  const toolSelectBtn = document.getElementById('toolSelect');

  const styleSel = document.getElementById('styleSel');
  const thicknessEl = document.getElementById('thickness');
  const thVal = document.getElementById('thVal');
  const colorEl = document.getElementById('color');
  const snapModeEl = document.getElementById('snapMode');

  const selInfo = document.getElementById('selInfo');
  const delBtn = document.getElementById('delBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');

  // ------- State
  const GRID = 10;
  const SNAP_DIST = 10;  // px aimantation sur points
  const HANDLE_R = 7;

  const TOOL = { ARROW:'arrow', SELECT:'select' };
  let tool = TOOL.ARROW;

  /** Arrow object:
   * { id, kind:'arrow', style:'straight'|'curved'|'double', color, thickness,
   *   x1,y1,x2,y2,
   *   cx,cy (for curved only)
   * }
   */
  let arrows = [];
  let selectedId = null;

  // Drawing temp
  let drawing = null; // {x1,y1,x2,y2, style, thickness, color, cx,cy}

  // Dragging selection
  let dragMove = null;   // moving whole arrow
  let dragHandle = null; // moving endpoint or control point

  // Copy buffer
  let clipboardArrow = null;

  // ------- Utils
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const uid = ()=>Math.random().toString(16).slice(2)+Date.now().toString(16);

  function setTool(next){
    tool = next;
    toolArrowBtn.classList.toggle('toggleOn', tool===TOOL.ARROW);
    toolSelectBtn.classList.toggle('toggleOn', tool===TOOL.SELECT);
  }

  function setSelected(id){
    selectedId = id;
    const a = arrows.find(x=>x.id===id);
    if (!a){
      selInfo.textContent = 'Aucune sélection';
      delBtn.disabled = true;
    } else {
      selInfo.textContent = `Sélection : ${a.style}`;
      delBtn.disabled = false;
    }
    render();
  }

  function svgEl(name, attrs){
    const el = document.createElementNS('http://www.w3.org/2000/svg', name);
    for (const [k,v] of Object.entries(attrs||{})) el.setAttribute(k, String(v));
    return el;
  }

  function getCanvasPos(e){
    const r = bgCanvas.getBoundingClientRect();
    const sx = bgCanvas.width / r.width;
    const sy = bgCanvas.height / r.height;
    return { x:(e.clientX - r.left)*sx, y:(e.clientY - r.top)*sy };
  }

  function hexToRgb01(hex){
    const h = (hex||'#000000').replace('#','');
    const r = parseInt(h.slice(0,2),16)/255;
    const g = parseInt(h.slice(2,4),16)/255;
    const b = parseInt(h.slice(4,6),16)/255;
    return { r,g,b };
  }

  function snapValue(v){ return Math.round(v/GRID)*GRID; }

  function collectSnapPoints(excludeId=null){
    // snap points from all arrows: endpoints + control points (curved)
    const pts = [];
    for (const a of arrows){
      if (excludeId && a.id===excludeId) continue;
      pts.push({x:a.x1,y:a.y1});
      pts.push({x:a.x2,y:a.y2});
      if (a.style==='curved') pts.push({x:a.cx,y:a.cy});
    }
    return pts;
  }

  function applySnap(pt, excludeId=null, shiftKey=false){
    const mode = snapModeEl.value;
    if (mode==='off' || shiftKey) return pt;

    let x = pt.x, y = pt.y;

    // grid snap
    if (mode==='on' || mode==='grid'){
      x = snapValue(x);
      y = snapValue(y);
    }

    // point snap
    if (mode==='on'){
      const pts = collectSnapPoints(excludeId);
      let best = null;
      let bestD = Infinity;
      for (const p of pts){
        const d = Math.hypot(p.x - x, p.y - y);
        if (d < bestD){
          bestD = d;
          best = p;
        }
      }
      if (best && bestD <= SNAP_DIST){
        x = best.x; y = best.y;
      }
    }

    return { x, y };
  }

  // ------- Arrow geometry (nice arrow)
  // We generate filled path (body + head) so it's pretty, like your screenshot.
  // For curved arrows, we generate centerline curve and build a "tube" + head at the end.
  function arrowHeadParams(t){
    // tuned for nice look
    const headL = Math.max(22, t * 4.2);
    const headW = Math.max(18, t * 3.2);
    return { headL, headW };
  }

  function pathStraightArrow(x1,y1,x2,y2,t, doubleHead=false){
    const dx = x2-x1, dy = y2-y1;
    const len = Math.hypot(dx,dy) || 1;
    const ux = dx/len, uy = dy/len;
    const px = -uy, py = ux;

    const { headL, headW } = arrowHeadParams(t);

    // base of head
    const bx = x2 - ux*headL;
    const by = y2 - uy*headL;

    // body start/end with thickness
    const t2 = t/2;

    // If double head, also build head at start
    let sx = x1, sy = y1;
    let sbx = x1 + ux*headL;
    let sby = y1 + uy*headL;

    // Build polygon points
    const pts = [];

    if (doubleHead){
      // start head (tip at start)
      pts.push({x:sx, y:sy});
      pts.push({x:sbx + px*headW/2, y:sby + py*headW/2});
      pts.push({x:sbx + px*t2, y:sby + py*t2});
    } else {
      pts.push({x:x1 + px*t2, y:y1 + py*t2});
    }

    // top edge to end head base
    pts.push({x:bx + px*t2, y:by + py*t2});
    pts.push({x:bx + px*headW/2, y:by + py*headW/2});
    pts.push({x:x2, y:y2});
    pts.push({x:bx - px*headW/2, y:by - py*headW/2});
    pts.push({x:bx - px*t2, y:by - py*t2});

    // bottom edge back to start
    if (doubleHead){
      pts.push({x:sbx - px*t2, y:sby - py*t2});
      pts.push({x:sbx - px*headW/2, y:sby - py*headW/2});
      pts.push({x:sx, y:sy});
      pts.push({x:sbx + px*headW/2, y:sby + py*headW/2}); // close pretty
    } else {
      pts.push({x:x1 - px*t2, y:y1 - py*t2});
    }

    // Make SVG path
    let d = `M ${pts[0].x} ${pts[0].y}`;
    for (let i=1;i<pts.length;i++) d += ` L ${pts[i].x} ${pts[i].y}`;
    d += ' Z';
    return d;
  }

  // Quadratic Bezier helpers
  function qPoint(t, p0, p1, p2){
    const u=1-t;
    return {
      x: u*u*p0.x + 2*u*t*p1.x + t*t*p2.x,
      y: u*u*p0.y + 2*u*t*p1.y + t*t*p2.y
    };
  }
  function qTangent(t, p0, p1, p2){
    // derivative: 2(1-t)(p1-p0) + 2t(p2-p1)
    return {
      x: 2*(1-t)*(p1.x-p0.x) + 2*t*(p2.x-p1.x),
      y: 2*(1-t)*(p1.y-p0.y) + 2*t*(p2.y-p1.y)
    };
  }

  // Build a "tube" along the curve by sampling offsets
  function pathCurvedArrow(x1,y1,cx,cy,x2,y2,t, doubleHead=false){
    const p0={x:x1,y:y1}, p1={x:cx,y:cy}, p2={x:x2,y:y2};
    const samples = 18; // enough to look smooth
    const t2 = t/2;
    const top=[], bot=[];

    for (let i=0;i<=samples;i++){
      const tt = i/samples;
      const p = qPoint(tt,p0,p1,p2);
      const tan = qTangent(tt,p0,p1,p2);
      const L = Math.hypot(tan.x,tan.y) || 1;
      const ux = tan.x/L, uy = tan.y/L;
      const px = -uy, py = ux;
      top.push({x:p.x + px*t2, y:p.y + py*t2});
      bot.push({x:p.x - px*t2, y:p.y - py*t2});
    }

    // Arrow head at end (use tangent near end)
    const tanE = qTangent(0.98,p0,p1,p2);
    const Le = Math.hypot(tanE.x,tanE.y) || 1;
    const uxe = tanE.x/Le, uye = tanE.y/Le;
    const pxe = -uye, pye = uxe;

    const { headL, headW } = arrowHeadParams(t);
    const bx = x2 - uxe*headL;
    const by = y2 - uye*headL;

    // Replace last points to match head base
    top[top.length-1] = {x:bx + pxe*t2, y:by + pye*t2};
    bot[bot.length-1] = {x:bx - pxe*t2, y:by - pye*t2};

    // Head triangle-ish but integrated (filled)
    const headPts = [
      {x:bx + pxe*headW/2, y:by + pye*headW/2},
      {x:x2, y:y2},
      {x:bx - pxe*headW/2, y:by - pye*headW/2}
    ];

    // Start head if double
    let startHeadPts = null;
    if (doubleHead){
      const tanS = qTangent(0.02,p0,p1,p2);
      const Ls = Math.hypot(tanS.x,tanS.y) || 1;
      const uxs = tanS.x/Ls, uys = tanS.y/Ls;
      const pxs = -uys, pys = uxs;

      const sbx = x1 + uxs*headL;
      const sby = y1 + uys*headL;

      top[0] = {x:sbx + pxs*t2, y:sby + pys*t2};
      bot[0] = {x:sbx - pxs*t2, y:sby - pys*t2};

      startHeadPts = [
        {x:sbx + pxs*headW/2, y:sby + pys*headW/2},
        {x:x1, y:y1},
        {x:sbx - pxs*headW/2, y:sby - pys*headW/2}
      ];
    }

    // Build path:
    // start at top[0] -> ... -> top[last] -> headPts[0]->tip->headPts[2] -> bot[last] -> ... -> bot[0] -> close
    let d = `M ${top[0].x} ${top[0].y}`;
    for (let i=1;i<top.length;i++) d += ` L ${top[i].x} ${top[i].y}`;
    d += ` L ${headPts[0].x} ${headPts[0].y}`;
    d += ` L ${headPts[1].x} ${headPts[1].y}`;
    d += ` L ${headPts[2].x} ${headPts[2].y}`;
    d += ` L ${bot[bot.length-1].x} ${bot[bot.length-1].y}`;
    for (let i=bot.length-2;i>=0;i--) d += ` L ${bot[i].x} ${bot[i].y}`;

    if (startHeadPts){
      d += ` L ${startHeadPts[2].x} ${startHeadPts[2].y}`;
      d += ` L ${startHeadPts[1].x} ${startHeadPts[1].y}`;
      d += ` L ${startHeadPts[0].x} ${startHeadPts[0].y}`;
    }

    d += ' Z';
    return d;
  }

  function arrowPath(a){
    const t = a.thickness;
    if (a.style==='straight'){
      return pathStraightArrow(a.x1,a.y1,a.x2,a.y2,t,false);
    }
    if (a.style==='double'){
      return pathStraightArrow(a.x1,a.y1,a.x2,a.y2,t,true);
    }
    // curved
    return pathCurvedArrow(a.x1,a.y1,a.cx,a.cy,a.x2,a.y2,t,false);
  }

  function arrowPathDoubleCurved(a){
    // if someday you want double curved, it's here (not exposed in UI by default)
    return pathCurvedArrow(a.x1,a.y1,a.cx,a.cy,a.x2,a.y2,a.thickness,true);
  }

  function computeBBox(a){
    const xs=[a.x1,a.x2], ys=[a.y1,a.y2];
    if (a.style==='curved'){ xs.push(a.cx); ys.push(a.cy); }
    const minX=Math.min(...xs), maxX=Math.max(...xs);
    const minY=Math.min(...ys), maxY=Math.max(...ys);
    const pad = Math.max(14, a.thickness*2);
    return { x:minX-pad, y:minY-pad, w:(maxX-minX)+pad*2, h:(maxY-minY)+pad*2 };
  }

  function hitTestHandle(a, pt){
    // returns 'p1'|'p2'|'c'|null
    const d1 = Math.hypot(pt.x-a.x1, pt.y-a.y1);
    if (d1 <= HANDLE_R+2) return 'p1';
    const d2 = Math.hypot(pt.x-a.x2, pt.y-a.y2);
    if (d2 <= HANDLE_R+2) return 'p2';
    if (a.style==='curved'){
      const dc = Math.hypot(pt.x-a.cx, pt.y-a.cy);
      if (dc <= HANDLE_R+2) return 'c';
    }
    return null;
  }

  function hitTestArrow(pt){
    // cheap hit test: bbox first, then distance to segment (straight) or to curve sample (curved)
    for (let i=arrows.length-1;i>=0;i--){
      const a = arrows[i];
      const bb = computeBBox(a);
      if (pt.x < bb.x || pt.x > bb.x+bb.w || pt.y < bb.y || pt.y > bb.y+bb.h) continue;

      const tol = Math.max(10, a.thickness*1.2);

      if (a.style==='straight' || a.style==='double'){
        const d = distPointToSegment(pt, {x:a.x1,y:a.y1}, {x:a.x2,y:a.y2});
        if (d <= tol) return a.id;
      } else {
        // curved: sample points
        const p0={x:a.x1,y:a.y1}, p1={x:a.cx,y:a.cy}, p2={x:a.x2,y:a.y2};
        let best=Infinity;
        for (let s=0;s<=24;s++){
          const t=s/24;
          const p=qPoint(t,p0,p1,p2);
          best=Math.min(best, Math.hypot(pt.x-p.x, pt.y-p.y));
        }
        if (best <= tol) return a.id;
      }
    }
    return null;
  }

  function distPointToSegment(p, a, b){
    const abx=b.x-a.x, aby=b.y-a.y;
    const apx=p.x-a.x, apy=p.y-a.y;
    const ab2=abx*abx+aby*aby || 1;
    let t=(apx*abx+apy*aby)/ab2;
    t=clamp(t,0,1);
    const x=a.x + t*abx;
    const y=a.y + t*aby;
    return Math.hypot(p.x-x, p.y-y);
  }

  // ------- Render (background + svg)
  function renderBackground(){
    // white page + subtle grid dots
    ctx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,bgCanvas.width,bgCanvas.height);

    // subtle grid (very light)
    ctx.fillStyle = 'rgba(0,0,0,0.04)';
    for (let y=0;y<=bgCanvas.height;y+=GRID){
      for (let x=0;x<=bgCanvas.width;x+=GRID){
        if ((x%50===0) && (y%50===0)) ctx.fillRect(x-1,y-1,2,2);
      }
    }
  }

  function render(){
    renderBackground();
    svg.innerHTML = '';
    const W = bgCanvas.width, H = bgCanvas.height;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.setAttribute('preserveAspectRatio','none');

    // draw arrows
    for (const a of arrows){
      const g = svgEl('g', {'data-id':a.id});
      const path = svgEl('path', {
        d: (a.style==='curved' ? (a.style==='curved' ? arrowPath(a) : arrowPath(a)) : arrowPath(a)),
        fill: a.color
      });
      g.appendChild(path);

      // selection bbox + handles
      if (a.id === selectedId){
        const bb = computeBBox(a);
        g.appendChild(svgEl('rect', {x:bb.x, y:bb.y, width:bb.w, height:bb.h, class:'selBox'}));

        g.appendChild(svgEl('circle', {cx:a.x1, cy:a.y1, r:HANDLE_R, class:'handleDot', 'data-handle':'p1'}));
        g.appendChild(svgEl('circle', {cx:a.x2, cy:a.y2, r:HANDLE_R, class:'handleDot', 'data-handle':'p2'}));
        if (a.style==='curved'){
          g.appendChild(svgEl('circle', {cx:a.cx, cy:a.cy, r:HANDLE_R, class:'handleDot', 'data-handle':'c'}));
        }
      }

      svg.appendChild(g);
    }

    // temp drawing ghost
    if (drawing){
      const ghost = svgEl('path', { d: arrowPath(drawing), fill: drawing.color });
      ghost.classList.add('ghost');
      svg.appendChild(ghost);
    }
  }

  // ------- Tool UI
  thicknessEl.addEventListener('input', ()=>{
    thVal.textContent = thicknessEl.value;
    // if selection exists, update thickness live
    const a = arrows.find(x=>x.id===selectedId);
    if (a){
      a.thickness = parseInt(thicknessEl.value,10);
      render();
    }
  });

  colorEl.addEventListener('input', ()=>{
    const a = arrows.find(x=>x.id===selectedId);
    if (a){
      a.color = colorEl.value;
      render();
    }
  });

  styleSel.addEventListener('change', ()=>{
    const a = arrows.find(x=>x.id===selectedId);
    if (a){
      a.style = styleSel.value;
      // If switched to curved, ensure control point exists
      if (a.style==='curved'){
        if (!Number.isFinite(a.cx) || !Number.isFinite(a.cy)){
          a.cx = (a.x1+a.x2)/2;
          a.cy = (a.y1+a.y2)/2 - 80;
        }
      }
      render();
      selInfo.textContent = a ? `Sélection : ${a.style}` : 'Aucune sélection';
    }
  });

  toolArrowBtn.addEventListener('click', ()=>setTool(TOOL.ARROW));
  toolSelectBtn.addEventListener('click', ()=>setTool(TOOL.SELECT));

  delBtn.addEventListener('click', ()=>{
    if (!selectedId) return;
    arrows = arrows.filter(a=>a.id!==selectedId);
    setSelected(null);
  });

  clearBtn.addEventListener('click', ()=>{
    arrows = [];
    setSelected(null);
  });

  // ------- Pointer events (draw / select / drag)
  svg.addEventListener('pointerdown', (e)=>{
    const pt = getCanvasPos(e);
    const shift = e.shiftKey;

    if (tool === TOOL.ARROW){
      // start drawing
      const base = applySnap(pt, null, shift);
      const style = styleSel.value;
      const thickness = parseInt(thicknessEl.value,10);
      const color = colorEl.value;

      drawing = {
        id: uid(),
        kind:'arrow',
        style,
        thickness,
        color,
        x1: base.x, y1: base.y,
        x2: base.x, y2: base.y
      };

      if (style==='curved'){
        drawing.cx = base.x;
        drawing.cy = base.y - 80;
      }

      svg.setPointerCapture(e.pointerId);
      render();
      return;
    }

    // SELECT mode
    const hitId = hitTestArrow(pt);
    if (!hitId){
      setSelected(null);
      return;
    }

    setSelected(hitId);
    const a = arrows.find(x=>x.id===hitId);
    if (!a) return;

    // handle drag?
    const handle = hitTestHandle(a, pt);
    if (handle){
      dragHandle = { id: hitId, handle, start: pt, orig: structuredClone(a), shift };
      svg.setPointerCapture(e.pointerId);
      render();
      return;
    }

    // move arrow
    dragMove = { id: hitId, start: pt, orig: structuredClone(a), shift };
    svg.setPointerCapture(e.pointerId);
    render();
  });

  svg.addEventListener('pointermove', (e)=>{
    const pt = getCanvasPos(e);
    const shift = e.shiftKey;

    if (drawing){
      const snapPt = applySnap(pt, null, shift);
      drawing.x2 = snapPt.x;
      drawing.y2 = snapPt.y;

      if (drawing.style==='curved'){
        // default control: mid with normal offset; user can edit later via handle
        const mx = (drawing.x1 + drawing.x2)/2;
        const my = (drawing.y1 + drawing.y2)/2;
        const dx = drawing.x2-drawing.x1, dy = drawing.y2-drawing.y1;
        const L = Math.hypot(dx,dy) || 1;
        const nx = -dy/L, ny = dx/L;
        const bump = 90; // curvature amount
        drawing.cx = mx + nx*bump;
        drawing.cy = my + ny*bump;
      }

      render();
      return;
    }

    if (dragHandle){
      const a = arrows.find(x=>x.id===dragHandle.id);
      if (!a) return;

      const snapped = applySnap(pt, dragHandle.id, shift);

      if (dragHandle.handle === 'p1'){
        a.x1 = snapped.x; a.y1 = snapped.y;
      } else if (dragHandle.handle === 'p2'){
        a.x2 = snapped.x; a.y2 = snapped.y;
      } else if (dragHandle.handle === 'c'){
        // control point snaps too
        a.cx = snapped.x; a.cy = snapped.y;
      }
      render();
      return;
    }

    if (dragMove){
      const a = arrows.find(x=>x.id===dragMove.id);
      if (!a) return;

      const dx = pt.x - dragMove.start.x;
      const dy = pt.y - dragMove.start.y;

      // move all points (snap applied to translation end)
      const x1 = dragMove.orig.x1 + dx;
      const y1 = dragMove.orig.y1 + dy;

      // snap translation by snapping p1 (best UX)
      const snappedP1 = applySnap({x:x1,y:y1}, dragMove.id, shift);
      const tdx = snappedP1.x - dragMove.orig.x1;
      const tdy = snappedP1.y - dragMove.orig.y1;

      a.x1 = dragMove.orig.x1 + tdx;
      a.y1 = dragMove.orig.y1 + tdy;
      a.x2 = dragMove.orig.x2 + tdx;
      a.y2 = dragMove.orig.y2 + tdy;

      if (a.style==='curved'){
        a.cx = dragMove.orig.cx + tdx;
        a.cy = dragMove.orig.cy + tdy;
      }

      render();
    }
  });

  svg.addEventListener('pointerup', (e)=>{
    if (drawing){
      // finalize
      const finalized = drawing;
      drawing = null;

      // If arrow too small, discard
      if (Math.hypot(finalized.x2-finalized.x1, finalized.y2-finalized.y1) < 6){
        render();
        return;
      }

      // if curved and control point not set, set mid
      if (finalized.style==='curved' && (!Number.isFinite(finalized.cx) || !Number.isFinite(finalized.cy))){
        finalized.cx = (finalized.x1+finalized.x2)/2;
        finalized.cy = (finalized.y1+finalized.y2)/2 - 80;
      }

      arrows.push(finalized);
      setSelected(finalized.id);

      // sync UI to selected
      thicknessEl.value = finalized.thickness; thVal.textContent = finalized.thickness;
      colorEl.value = finalized.color;
      styleSel.value = finalized.style;

      render();
    }

    dragMove = null;
    dragHandle = null;
  });

  // ------- Keyboard: delete, copy, paste
  window.addEventListener('keydown', (e)=>{
    const isMac = navigator.platform.toUpperCase().includes('MAC');
    const mod = isMac ? e.metaKey : e.ctrlKey;

    // Delete
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedId){
      e.preventDefault();
      arrows = arrows.filter(a=>a.id!==selectedId);
      setSelected(null);
      return;
    }

    // Copy
    if (mod && (e.key.toLowerCase() === 'c') && selectedId){
      e.preventDefault();
      const a = arrows.find(x=>x.id===selectedId);
      if (!a) return;
      clipboardArrow = structuredClone(a);
      return;
    }

    // Paste
    if (mod && (e.key.toLowerCase() === 'v') && clipboardArrow){
      e.preventDefault();
      const a = structuredClone(clipboardArrow);
      a.id = uid();
      // offset a bit
      a.x1 += 20; a.y1 += 20;
      a.x2 += 20; a.y2 += 20;
      if (a.style==='curved'){ a.cx += 20; a.cy += 20; }
      arrows.push(a);
      setSelected(a.id);
      thicknessEl.value = a.thickness; thVal.textContent = a.thickness;
      colorEl.value = a.color;
      styleSel.value = a.style;
      render();
      return;
    }
  });

  // ------- Export PDF (robust)
  exportBtn.addEventListener('click', async ()=>{
    exportBtn.disabled = true;
    exportBtn.textContent = 'Export...';
    try{
      const pdf = await PDFDocument.create();
      const page = pdf.addPage([bgCanvas.width, bgCanvas.height]);

      for (const a of arrows){
        const c = hexToRgb01(a.color);

        // Convert canvas coords (0,0 top-left) -> PDF coords (0,0 bottom-left)
        const flipY = (y)=> (bgCanvas.height - y);

        let d;
        if (a.style==='curved'){
          // We already produce a filled path in canvas coordinates.
          // Just flip Y values by rebuilding using flipped points.
          const aa = structuredClone(a);
          aa.y1 = flipY(a.y1);
          aa.y2 = flipY(a.y2);
          aa.cy = flipY(a.cy);
          d = pathCurvedArrow(aa.x1,aa.y1,aa.cx,aa.cy,aa.x2,aa.y2,aa.thickness,false);
        } else if (a.style==='double'){
          const y1 = flipY(a.y1), y2 = flipY(a.y2);
          d = pathStraightArrow(a.x1,y1,a.x2,y2,a.thickness,true);
        } else {
          const y1 = flipY(a.y1), y2 = flipY(a.y2);
          d = pathStraightArrow(a.x1,y1,a.x2,y2,a.thickness,false);
        }

        // ✅ drawSvgPath avoids drawPolygon errors
        page.drawSvgPath(d, { color: rgb(c.r,c.g,c.b) });
      }

      const bytes = await pdf.save();
      const blob = new Blob([bytes], {type:'application/pdf'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'export.pdf';
      a.click();
      URL.revokeObjectURL(url);
    } catch(err){
      alert('Erreur export : ' + (err?.message || err));
      console.error(err);
    } finally {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Exporter PDF';
    }
  });

  // ------- Init
  function resizeOverlayToCanvas(){
    const W = bgCanvas.width, H = bgCanvas.height;
    svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', '100%');
  }

  thVal.textContent = thicknessEl.value;
  setTool(TOOL.ARROW);
  resizeOverlayToCanvas();
  renderBackground();
  render();

})();
</script>
</body>
</html>
